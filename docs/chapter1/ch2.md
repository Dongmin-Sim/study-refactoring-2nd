# 2장 : 리팩터링 원칙

## 리팩터링의 정의 
리팩터링이란 용어는 명사로도 쓸 수 있고, 동사로도 쓸 수 있다. 
명사로 사용할 경우 다음과 같이 정의한다.
> 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- `함수 추출하기`, `조건부 로직을 다형성으로 바꾸기` 와 같은 이름 붙은 리팩터링 기법들이 이에 해당함.

동사로 사용할 경우 리팩터링의 정의는 다음과 같음. 
> 소프트웨어의 겉보기 동작은 그대로 유지한 체, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성함.

기존의 통용되던 '리팩터링'은 코드를 정리하는 작업을 모두 의미하는 경우가 많았지만, 앞선 정의에 따르면 "특정한 방식"에 따라 코드를 정리하는 것만이 리팩터링이다. 

리팩터링은 결국 **동작을 보존하는 작은 단계들**을 거쳐 코드를 수정하고, 이러한 단계들을 **순차적으로 연결**하여 큰 변화를 이끌어내는 일.
- 개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계가 여러 개 합쳐진 모습일 수도 있다. 
- 코드가 항상 동작하기 때문에, 전체 작업이 끝나지 않더라고 언제든지 멈출 수 있다.

책에서 저자는 코드 베이스를 정리하고나 구조를 바꾸는 모든 작업을 "재구성(restructuring)"이라는 포괄적 용어로 표현하고, 리팩터링은 재구성의 특수한 형태로 봄.

앞의 리팩터링 정의에서 "겉보기 동작"이라는 표현은 리팩터링 전과 후의 코드가 **똑같이 동작**해야 한다는 것을 의미하는 표현이다.
- `함수 추출하기`를 거치면, 콜스택이 달라져서 성능이 변할 수 있지만, 사용자 관점에서는 달라지는 점이 없어야 함.
- `함수 선언 바꾸기`, `함수 옮기기`를 거치면 인터페이스가 변경되지만, 이전에 발견된 버그는 리팩터링 이후에도 그대로 남아있어야 한다.
- 중요한 것은 전과 후의 결과 동작이 바뀌면 진정한 의미의 리팩터링이 아니지 않을까

리팩터링은 성능 최적화와 비슷함. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지함. 목적이 다르다.
- 리팩터링의 목적은 코드를 _이해하고, 수정하기_ 쉽게 만드는 것. 이에 따라 성능이 좋아질수도 나빠질수도 있음.
- 성능최적화는 오로지 속도 개선에만 신경 씀
  - 목표 성능에 반드시 도달해야한다면, 코드를 다루기 어려운 구조로 바뀔 수도 있다는 것을 각오.
  - 💭 '리팩터링'과 '성능최적화'는 코드의 구조의 '복잡함' 측면에서 어느정도 트레이드 오프가 있을 수 있다는 말일까?

## 두 개의 모자
저자는 소프트웨어를 개발할 때 목적이 1. '기능 추가'인지, 2. '리팩터링'인지를 명확하게 구분해서 작업함. 
켄트 백은 이를 2개의 모자에 비유했음. 기능 추가를 할때는 '기능 추가'모자를 쓴 다음 기존 코드는 건들이지 않고 새 기능을 추가하기만함. 
진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정.

반면 리팩터링할 때는 '리팩터링' 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐 후 오로지 코드 재구성에만 전념. 테스트도 새로 만들지 않는다.
부득이 인터페이스를 변경할 때문 기존 테스트 수정.

저자는 개발하는 동안 이 두 모드를 번갈아 가면서 진행한다고 함. 기능 추가시, 코드 구조 변경이 기능추가에 유리할 경우. 리팩터링 모자를 쓰고 리팩터링에 전념.
이후 기능추가가 용이해지면 다시 기능추가 모드로 변경해서 진행한다고 함. 선택한 모자(모드)에 따라 미묘한 작업 방식의 차이를 인지.


## 리팩터링을 왜 해야하는 걸까?

리팩터링이 모든 문제점을 해결해주니는 않지만, 코드를 건강한 상태로 유지해주는 도구로 인식.  
코드를 이해하기 쉽고 수정하기 쉽게 만드는 것이 목표. 

### 소프트웨어 설계가 썩지 않는다.
아키텍쳐를 충분히 이해하지 못한 채 단기 목표만들 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 그러면 코드만 봐서는 설계를 파악하기 어려워진다. 

코드 구조가 무너지기 시작하면 악효과가 누적된다. 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다.

리팩터링은 이러한 부패가 진행되는 것을 막아준다고 함.  
그 중 사실상 같은 일을 하는 코드가 여러 곳에 나타나는 경우 이를 제거하는 것이 설계 개선 작업의 중요한 축이 된다. 
중복코드를 제거함으로써 (물리적인 코드량이 주는 것이) 시스템의 성능에 큰 영향을 미치지는 않지만 **수정하는 데 드는 노력은 크게 달라짐.**

> 💭 '코드/설계가 부패한다'라는 표현이 인상 깊었다. 코드를 하나의 유기체로 보아야만 부패라는 단어가 어울린다.  
> 
> "코드만으로 설계를 파악하기 어려워질수록" 이라는 문장이 있는데, 코드를 이해하기 위한 주석들이 많아질 경우 부패되고 있는 중이라는 하나의 힌트로 작용할 수 있지 않을까?
> 
> 중복 코드를 제거하는 것은 변경 포인트를 하나로 몰아 넣는다는 점에서 의미가 있다고 이해했다. 수정하는데 드는 비용과 시스템의 안정성을 위해.

### 소프트웨어를 이해하는데 도움이 된다.

프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일. 이제 내 소스코드를 다른 사람들이 읽고 수정하게 될 때 이를 이해하는데 매우 오랜 시간이 걸린다면 바람직한 일이 아님. 

프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있음.  
리팩터링은 코드가 더 잘 읽히게 도와준다. 잘 작동하지만, 이상적인 구조가 아닌 코드가 있다면, 잠시 시간을 내서 리팩터링.
- 코드의 목적이 더 잘 드러나게 

이는 다른 사람을 배려하는 것뿐만 아니라 미래의 나 자신에게도 해당되는 것임. 내가 코드를 달달 외우고 있는 경우는 잘 없음. 코드를 보면 알 수 있는 것들은 코드속에 명확하게 담아주는 것이어야 함.
몇 주후 내가 짠 코드를 읽는데 어려움을 겪을 수도 있음. 

> 💭 내가 짰던 코드들을 나중에 읽는데 즐겁지 않다면 끔찍할 것.. 보기 싫은 코드 == 이해하기 어려운 코드, 읽는데 에너지 소모가 많은 코드.
> 리팩터링은 이러한 코드들을 보기 좋은 코드 == 이해하기 쉬운 코드로 만들어주는 작업이지 않을까. + 새로운 기능을 추가하는데도 훨씬 수월하게 만들어주는 도구.

### 버그를 쉽게 찾을 수 있다.
코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 함.